#!/usr/bin/python

"""%prog [OPTIONS] SOURCE_DIRECTORY [SOURCE_DIRECTORY...] DESTINATION_DIRECTORY.

Link all files in SOURCE_DIRECTORY [SOURCE_DIRECTORY...] to
DESTINATION_DIRECTORY, creating the destination directory hierarchy where
necessary.
"""

import collections
import difflib
import fnmatch
import optparse
import os
import pipes
import shutil
import stat
import sys
import time

__author__ = "johntobin@johntobin.ie (John Tobin)"


class Error(Exception):
  """Base class for exceptions."""
  pass


class ArgumentError(Error):
  """Something was wrong with one of the arguments passed to a function."""


class UnexpectedFileError(Error):
  """A file or directory was expected, but something else was found."""


# expected_files is a list of files and directories that should exist in the
# destination.  diffs is a list of diffs between source and destination files.
LinkResults = collections.namedtuple('LinkResults', 'expected_files diffs')


def SafeUnlink(unlink_me, dryrun=True):
  """Remove a file or directory, or return shell commands that would do so.

  Args:
    unlink_me: the file or directory to be removed.
    dryrun:    if True, shell commands are returned; if False, unlink_me is
               removed.  Defaults to True.

  Returns:
    Nothing if dryrun is false, a string if dryrun is true.

  Raises:
    OSError: there was a problem removing unlink_me.
  """

  if os.path.islink(unlink_me) or not os.path.isdir(unlink_me):
    if dryrun:
      return "rm %s" % pipes.quote(unlink_me)
    else:
      os.unlink(unlink_me)
  else:
    if dryrun:
      return "rm -r %s" % pipes.quote(unlink_me)
    else:
      shutil.rmtree(unlink_me)


def PrintIfNotNone(something):
  """Prints something if it is not None.

  Args:
    something: a thing to print if it is not None.

  Returns:
    Nothing.
  """

  if something:
    print something


def Diff(old_filename, new_filename):
  """Return a diff between old and new files.

  Args:
    old_filename: the original file.
    new_filename: the new file.

  Returns:
    An array of strings, possibly empty.

  Raises:
    OSError: an error occurred reading one of the files.
  """

  old_timestamp = time.ctime(os.stat(old_filename).st_mtime)
  old_contents = open(old_filename, "r").readlines()
  new_timestamp = time.ctime(os.stat(new_filename).st_mtime)
  new_contents = open(new_filename, "r").readlines()
  diff_generator = difflib.unified_diff(new_contents, old_contents,
                                        new_filename, old_filename,
                                        new_timestamp, old_timestamp)
  diffs = [diff for diff in diff_generator]
  return diffs


def RemoveSkipPatterns(files, skip):
  """Remove any files matching shell patterns.

  Args:
    files: a list of filenames.
    skip: a list of shell patterns.

  Returns:
    An array of filenames.
  """

  if not skip:
    return files
  unmatched = []
  for filename in files:
    for pattern in skip:
      if fnmatch.fnmatch(filename, pattern):
        break
    else:
      unmatched.append(filename)
  return unmatched


def LinkDir(source, dest, skip, dryrun, force):
  """Recursively link files in source directory to dest directory.

  Args:
    source:       the source directory
    dest:         the destination directory
    skip:         files and directories under source that will be skipped.
    dryrun:       if true, the filesystem will not be changed; shell commands
                  will be printed instead.
    force:        existing files will be removed if necessary.  dryrun overrides
                  force.

  Returns:
    LinkResults.

  Raises:
    ArgumentError:       something was wrong with source or dest argument.
    OSError:             a filesystem operation failed.
    UnexpectedFileError: a file or directory was expected, but something else
                         was found instead.
  """

  if not os.path.isdir(source):
    raise ArgumentError("%s is not a directory" % source)

  expected_files = []
  diffs = []
  for directory, subdirs, files in os.walk(source, topdown=True):
    # Remove skippable subdirs.  Assigning to the slice will prevent os.walk
    # from descending into the skipped subdirs.
    subdirs[:] = RemoveSkipPatterns(subdirs, skip)
    for subdir in subdirs:
      source_dir = os.path.join(directory, subdir)
      dest_dir = source_dir.replace(source, dest, 1)
      expected_files.append(dest_dir)
      source_stat = os.stat(source_dir)
      source_mode = stat.S_IMODE(source_stat.st_mode)

      if os.path.isdir(dest_dir):
        if not dryrun:
          os.chmod(dest_dir, source_mode)
        continue

      if os.path.exists(dest_dir):
        if force:
          PrintIfNotNone(SafeUnlink(dest_dir, dryrun=dryrun))
        else:
          raise UnexpectedFileError("%s is not a directory" % dest_dir)

      if dryrun:
        PrintIfNotNone("mkdir %s" % pipes.quote(dest_dir))
      else:
        os.mkdir(dest_dir, source_mode)
        os.chmod(dest_dir, source_mode)

    results = LinkFiles(source, dest, directory, files,
                        dryrun=dryrun, force=force, skip=skip)
    expected_files.extend(results.expected_files)
    diffs.extend(results.diffs)

  return LinkResults(expected_files, diffs)


def LinkFiles(source, dest, directory, files, dryrun, force, skip):
  """Link files from source to dest.

  Args:
    source:    the toplevel source directory.
    dest:      the toplevel dest directory.
    directory: the directory the files are in, relative to source and dest.
    files:     the files in source/directory.
    dryrun:    if true, the filesystem will not be changed.
    force:     existing files will be removed if necessary.  dryrun overrides
               force.
    skip:      a list of filenames to skip.

  Returns:
    LinkResults.  expected_files will not include files that are skipped.

  Raises:
    UnexpectedFileError: A file or directory was expected, but something else
                         was found instead.
  """

  expected_files = []
  diffs = []
  files = RemoveSkipPatterns(files, skip)
  files = [os.path.join(directory, filename) for filename in files]
  skip_more = ["*%s%s" % (os.sep, pattern) for pattern in skip]
  files = RemoveSkipPatterns(files, skip_more)
  for source_filename in files:
    dest_filename = source_filename.replace(source, dest, 1)
    expected_files.append(dest_filename)

    # To correctly fake things during a dryrun, we need to remember when we
    # delete a destination file.
    file_was_removed = False

    if (os.path.islink(dest_filename)
        or (os.path.exists(dest_filename)
            and not os.path.isfile(dest_filename))):
      if force:
        PrintIfNotNone(SafeUnlink(dest_filename, dryrun=dryrun))
        file_was_removed = True
      else:
        raise UnexpectedFileError("%s: is not a file" % dest_filename)

    if os.path.exists(dest_filename) and not file_was_removed:
      if os.path.samefile(source_filename, dest_filename):
        # The file is correctly linked.
        continue

      if not force:
        file_diffs = Diff(source_filename, dest_filename)
        if not file_diffs:
          num_links = os.stat(dest_filename)[stat.ST_NLINK]
          if num_links != 1 and not force:
            raise UnexpectedFileError("%s: link count is %d"
                                      % (dest_filename, num_links))
          print ("%s and %s are different files but have the same contents; "
                 "deleting and linking"
                 % (source_filename, dest_filename))
          PrintIfNotNone(SafeUnlink(dest_filename, dryrun=dryrun))
          file_was_removed = True
        else:
          diffs.extend(file_diffs)

      if force and not file_was_removed:
        PrintIfNotNone(SafeUnlink(dest_filename, dryrun=dryrun))
        file_was_removed = True

    if os.path.islink(source_filename):
      print "Skipping symbolic link %s" % source_filename
      continue
    if file_was_removed or not os.path.exists(dest_filename):
      if dryrun:
        PrintIfNotNone("ln %s %s" % (pipes.quote(source_filename),
                                     pipes.quote(dest_filename)))
      else:
        os.link(source_filename, dest_filename)

  return LinkResults(expected_files, diffs)


def ReportUnexpectedFilesInDestDir(dest_dir, expected_files_list, skip,
                                   ignore_unexpected_children=False):
  """Check for files in destdir that aren't in source_dir.

  Args:
    dest_dir: the destination directory.
    expected_files_list: a list of files expected to exist in the destination.
    skip: files and directories under source that will be skipped.
    ignore_unexpected_children: Ignore unexpected top level directories.
                                Defaults to false.

  Returns:
    (dirs, files): A list of files and directories in dest_dir that aren't in
                   source_dir.
  """

  expected_files = {dest_dir: 1}
  for entry in expected_files_list:
    expected_files[entry] = 1

  unexpected_msgs = []
  unexpected_paths = {
    "directory": [],
    "file": []
  }
  for directory, subdirs, files in os.walk(dest_dir, topdown=True):
    subdirs[:] = RemoveSkipPatterns(subdirs, skip)
    files = RemoveSkipPatterns(files, skip)

    if directory == dest_dir and ignore_unexpected_children:
      unexpected = [subdir for subdir in subdirs
                    if os.path.join(directory, subdir) not in expected_files]
      for subdir in unexpected:
        subdirs.remove(subdir)

    full_subdirs = [os.path.join(directory, entry) for entry in subdirs]
    full_files = [os.path.join(directory, entry) for entry in files]
    skip_more = ["*%s%s" % (os.sep, pattern) for pattern in skip]
    full_files = RemoveSkipPatterns(full_files, skip_more)
    for (my_list, my_type) in ((full_subdirs, "directory"),
        (full_files, "file")):
      for entry in my_list:
        if entry not in expected_files:
          unexpected_msgs.append("Unexpected %s: %s" % (my_type, entry))
          unexpected_paths[my_type].append(entry)

  unexpected_msgs.sort()
  for line in unexpected_msgs:
    print line
  unexpected_paths["file"].sort()
  unexpected_paths["directory"].sort()
  if unexpected_paths["file"]:
    print "rm %s" % " ".join(unexpected_paths["file"])
  if unexpected_paths["directory"]:
    print "rmdir %s" % " ".join(unexpected_paths["directory"])


def UnLineWrapString(a_string):
  """Undo line wrapping.

  Replace all whitespace sequences with a single space, and strip leading and
  trailing whitespace.

  Args:
    a_string: the string to be unwrapped.

  Returns:
    A string.
  """

  return " ".join(a_string.split()).strip()


def ReadSkipPatternsFromFile(filename):
  """Read skip patterns from filename, ignoring comments and empty lines."""
  patterns = []
  with open(filename) as f:
    for line in f.readlines():
      line = line.strip()
      if line and not line.startswith("#"):
        patterns.append(line)
  return patterns

def main(argv):
  # __doc__ is written to pass pylint checks, so it must be changed before being
  # used as a usage message.
  usage = __doc__.rstrip().replace(".", "", 1)
  argv_parser = optparse.OptionParser(usage=usage, version="%prog 1.0")
  argv_parser.add_option(
      "--dryrun", action="store_true", dest="dryrun", default=False,
      help=UnLineWrapString("""Perform a trial run with no changes made
                            (default: %default)"""))
  argv_parser.add_option(
      "--force", action="store_true", dest="force", default=False,
      help=UnLineWrapString("""Remove existing files if necessary (default:
                            %default)"""))
  argv_parser.add_option(
      "--ignore_file", action="append", dest="ignore_file", metavar="FILENAME",
      default=[],
      help=UnLineWrapString("""File containing shell patterns to ignore.  To
                            specify multiple filenames, use this option multiple
                            times."""))
  argv_parser.add_option(
      "--ignore_pattern", action="append", dest="ignore_pattern",
      metavar="FILENAME",
      default=[
        "CVS", ".git", ".gitignore", ".gitmodules", ".hg", ".svn", "*.swp"],
      help=UnLineWrapString("""Extra shell patterns to ignore (appended to this
                            list: %default).  To specify multiple filenames, use
                            this option multiple times."""))
  argv_parser.add_option(
      "--ignore_unexpected_children", action="store_true",
      dest="ignore_unexpected_children", default=False,
      help=UnLineWrapString("""When checking for unexpected files or
                            directories, ignore unexpected child directories in
                            DESTINATION_DIRECTORY; unexpected grandchild
                            directories of DESTINATION_DIRECTORY will not be
                            ignored (default: %default)"""))
  argv_parser.add_option(
      "--report_unexpected_files", action="store_true",
      dest="report_unexpected_files", default=False,
      help=UnLineWrapString("""Report unexpected files in DESTINATION_DIRECTORY
                            (default: %default)"""))

  (options, args) = argv_parser.parse_args(argv[1:])
  if len(args) < 2:
    sys.exit("Usage: %s [OPTIONS] SOURCE_DIR [SOURCE_DIR...] DEST_DIR"
             % argv[0])

  ignore_patterns = options.ignore_pattern[:]
  for filename in options.ignore_file:
    ignore_patterns.extend(ReadSkipPatternsFromFile(filename))

  all_results = LinkResults([], [])
  try:
    dest = args.pop().rstrip(os.sep)
    if not os.path.isdir(dest):
      os.mkdir(dest)
    for source in args:
      source = source.rstrip(os.sep)
      results = LinkDir(source, dest, skip=ignore_patterns,
                        dryrun=options.dryrun, force=options.force)
      all_results.expected_files.extend(results.expected_files)
      all_results.diffs.extend(results.diffs)
    if options.report_unexpected_files:
      ReportUnexpectedFilesInDestDir(
          dest, expected_files_list=all_results.expected_files,
          skip=ignore_patterns,
          ignore_unexpected_children=options.ignore_unexpected_children)
  except ArgumentError, arg_error:
    sys.exit("%s: %s" % (argv[0], arg_error.args[0]))
  except UnexpectedFileError, unexpected_file:
    sys.exit("%s: %s" % (argv[0], unexpected_file.args[0]))

  if all_results.diffs:
    for diff in all_results.diffs:
      print diff,
    sys.exit(1)


if __name__ == "__main__":
  main(sys.argv)
