#!/usr/bin/python

"""%prog [OPTIONS] SOURCE_DIRECTORY DESTINATION_DIRECTORY.

Link all files in SOURCE_DIRECTORY to DESTINATION_DIRECTORY, creating
the destination directory hierarchy where necessary.
"""

# XXX add an option to skip file patterns, and make *.swp part of the default.

import difflib
import optparse
import os
import pipes
import shutil
import stat
import sys
import time

__author__ = "johntobin@google.com (John Tobin)"


class Error(Exception):
  """Base class for exceptions."""
  pass


class ArgumentError(Error):
  """Something was wrong with one of the arguments passed to a function."""


class UnexpectedFileError(Error):
  """A file or directory was expected, but something else was found."""


def SafeUnlink(unlink_me, dryrun=True):
  """Remove a file or directory, or return shell commands that would do so.

  Args:
    unlink_me: the file or directory to be removed.
    dryrun:    if True, shell commands are returned; if False, unlink_me is
               removed.  Defaults to True.

  Returns:
    Nothing if dryrun is false, a string if dryrun is true.

  Raises:
    OSError: there was a problem removing unlink_me.
  """

  if os.path.islink(unlink_me) or not os.path.isdir(unlink_me):
    if dryrun:
      return "rm %s" % pipes.quote(unlink_me)
    else:
      os.unlink(unlink_me)
  else:
    if dryrun:
      return "rm -r %s" % pipes.quote(unlink_me)
    else:
      shutil.rmtree(unlink_me)


def PrintIfNotNone(something):
  """Prints something if it is not None.

  Args:
    something: a thing to print if it is not None.

  Returns:
    Nothing.
  """

  if something:
    print something


def Diff(old_filename, new_filename):
  """Return a diff between old and new files.

  Args:
    old_filename: the original file.
    new_filename: the new file.

  Returns:
    An array of strings, possibly empty.

  Raises:
    OSError: an error occurred reading one of the files.
  """

  old_timestamp = time.ctime(os.stat(old_filename).st_mtime)
  old_contents = open(old_filename, "r").readlines()
  new_timestamp = time.ctime(os.stat(new_filename).st_mtime)
  new_contents = open(new_filename, "r").readlines()
  diff_generator = difflib.unified_diff(new_contents, old_contents,
                                        new_filename, old_filename,
                                        new_timestamp, old_timestamp)
  diffs = [diff for diff in diff_generator]
  return diffs


def LinkDir(source, dest, skip=None, dryrun=False, force=False):
  """Recursively link files in source directory to dest directory.

  Args:
    source:       the source directory
    dest:         the destination directory
    skip:         files and directories under source that will be skipped.
                  Defaults to None.
    dryrun:       if true, the filesystem will not be changed; shell commands
                  will be printed instead.  Defaults to false.
    force:        existing files will be removed if necessary.  dryrun overrides
                  force.

  Returns:
    A list of files and directories that should exist in the destination.

  Raises:
    ArgumentError:       something was wrong with source or dest argument.
    OSError:             a filesystem operation failed.
    UnexpectedFileError: a file or directory was expected, but something else
                         was found instead.
  """

  (source, dest) = (source.rstrip("/"), dest.rstrip("/"))
  if not os.path.isdir(source):
    raise ArgumentError("%s is not a directory" % source)

  expected_files = []
  for directory, subdirs, files in os.walk(source, topdown=True):

    if skip:
      for skip_dir in skip:
        # Remove VCS dirs
        if skip_dir in subdirs:
          subdirs.remove(skip_dir)

    for subdir in subdirs:
      source_dir = os.path.join(directory, subdir)
      dest_dir = source_dir.replace(source, dest, 1)
      expected_files.append(dest_dir)
      source_stat = os.stat(source_dir)
      source_mode = stat.S_IMODE(source_stat.st_mode)

      if os.path.isdir(dest_dir):
        if not dryrun:
          os.chmod(dest_dir, source_mode)
        continue

      if os.path.exists(dest_dir):
        if force:
          PrintIfNotNone(SafeUnlink(dest_dir, dryrun=dryrun))
        else:
          raise UnexpectedFileError("%s is not a directory" % dest_dir)

      if dryrun:
        # This allows us to intercept PrintIfNotNone for testing.
        PrintIfNotNone("mkdir %s" % pipes.quote(dest_dir))
      else:
        os.mkdir(dest_dir, source_mode)
        os.chmod(dest_dir, source_mode)

    expected_files.extend(LinkFiles(source, dest, directory, files,
                                    dryrun=dryrun, force=force, skip=skip))

  return expected_files


def LinkFiles(source, dest, directory, files,
              dryrun=False, force=False, skip=None):
  """Link files from source to dest.

  Args:
    source:    the toplevel source directory.
    dest:      the toplevel dest directory.
    directory: the directory the files are in, relative to source and dest.
    files:     the files in source/directory.
    dryrun:    if true, the filesystem will not be changed.  Defaults to false.
    force:     existing files will be removed if necessary.  dryrun overrides
               force.
    skip:      a list of filenames to skip.  Defaults to None.

  Returns:
    A list of files and directories that should exist in the destination,
    excluding files that are skipped.

  Raises:
    UnexpectedFileError: A file or directory was expected, but something else
                         was found instead.
  """

  expected_files = []
  for filename in files:
    if skip and filename in skip:
      continue

    source_filename = os.path.join(directory, filename)
    dest_filename = source_filename.replace(source, dest, 1)
    expected_files.append(dest_filename)

    # To correctly fake things during a dryrun, we need to remember when we
    # delete a destination file.
    file_was_removed = False

    if (os.path.islink(dest_filename)
        or (os.path.exists(dest_filename)
            and not os.path.isfile(dest_filename))):
      if force:
        PrintIfNotNone(SafeUnlink(dest_filename, dryrun=dryrun))
        file_was_removed = True
      else:
        raise UnexpectedFileError("%s: is not a file" % dest_filename)

    if os.path.exists(dest_filename) and not file_was_removed:
      if os.path.samefile(source_filename, dest_filename):
        # The file is correctly linked.
        continue

      if not force:
        diffs = Diff(source_filename, dest_filename)
        if not diffs:

          num_links = os.stat(dest_filename)[stat.ST_NLINK]
          if num_links != 1 and not force:
            raise UnexpectedFileError("%s: link count is %d"
                                      % (dest_filename, num_links))

          print ("%s and %s are different files but have the same contents; "
                 "deleting and linking"
                 % (source_filename, dest_filename))
          PrintIfNotNone(SafeUnlink(dest_filename, dryrun=dryrun))
          file_was_removed = True
        else:
          for diff in diffs:
            print diff,

      if force and not file_was_removed:
        PrintIfNotNone(SafeUnlink(dest_filename, dryrun=dryrun))
        file_was_removed = True

    if file_was_removed or not os.path.exists(dest_filename):
      if dryrun:
        PrintIfNotNone("ln %s %s" % (pipes.quote(source_filename),
                                     pipes.quote(dest_filename)))
      else:
        os.link(source_filename, dest_filename)

  return expected_files


def ReportUnexpectedFilesInDestDir(dest_dir, expected_files_list,
                                   ignore_unexpected_children=False):
  """Check for files in destdir that aren't in source_dir.

  Args:
    dest_dir: the destination directory.
    expected_files_list: a list of files expected to exist in the destination.
    ignore_unexpected_children: Ignore unexpected top level files and
                                directories.  Defaults to false.

  Returns:
    (dirs, files): A list of files and directories in dest_dir that aren't in
                   source_dir.
  """

  expected_files = {dest_dir: 1}
  for entry in expected_files_list:
    expected_files[entry] = 1

  for directory, subdirs, files in os.walk(dest_dir, topdown=True):
    if directory == dest_dir and ignore_unexpected_children:
      unexpected = [subdir for subdir in subdirs
                    if os.path.join(directory, subdir) not in expected_files]
      for subdir in unexpected:
        subdirs.remove(subdir)
      for filename in files:
        expected_files[os.path.join(directory, filename)] = 1

    for (my_list, my_type) in ((subdirs, "directory"), (files, "file")):
      for entry in my_list:
        full_path = os.path.join(directory, entry)
        if full_path not in expected_files:
          print >> sys.stderr, "Unexpected %s: %s" % (my_type, full_path)


def UnLineWrapString(a_string):
  """Undo line wrapping.

  Replace all whitespace sequences with a single space, and strip leading and
  trailing whitespace.

  Args:
    a_string: the string to be unwrapped.

  Returns:
    A string.
  """

  return " ".join(a_string.split()).strip()


def main(argv):
  # __doc__ is written to pass pylint checks, so it must be changed before being
  # used as a usage message.
  usage = __doc__.rstrip().replace(".", "", 1)
  argv_parser = optparse.OptionParser(usage=usage, version="%prog 1.0")
  argv_parser.add_option("-d", "-n", "--dryrun",
                         action="store_true", dest="dryrun", default=False,
                         help=UnLineWrapString("""Perform a trial run with no
                                               changes made (default:
                                               %default)"""))
  argv_parser.add_option("-f", "--force",
                         action="store_true", dest="force", default=False,
                         help=UnLineWrapString("""Remove existing files if
                                               necessary (default:
                                               %default)"""))
  argv_parser.add_option("-i", "--ignore_unexpected_children",
                         action="store_true", dest="ignore_unexpected_children",
                         default=False,
                         help=UnLineWrapString("""When checking for unexpected
                                               files or directories, ignore
                                               children of
                                               DESTINATION_DIRECTORY;
                                               grandchildren of
                                               DESTINATION_DIRECTORY will not be
                                               ignored (default: %default)"""))
  argv_parser.add_option("-r", "--report_unexpected_files",
                         action="store_true", dest="report_unexpected_files",
                         default=False,
                         help=UnLineWrapString("""Report unexpected files in
                                               DESTINATION_DIRECTORY (default:
                                               %default)"""))
  argv_parser.add_option("-s", "--skip",
                         action="append", dest="skip",
                         metavar="FILENAME",
                         default=["CVS", ".svn", ".hg", ".git"],
                         help=UnLineWrapString("""Extra files or directories to
                                               skip (appended to this list:
                                               %default).  To specify multiple
                                               filenames, use this option
                                               multiple times."""))
  (options, args) = argv_parser.parse_args(argv[1:])
  if len(args) != 2:
    sys.exit("Usage: %s [OPTIONS] SOURCE_DIR DEST_DIR" % argv[0])

  try:
    (source, dest) = (args[0], args[1])
    expected_files = LinkDir(source, dest, skip=options.skip,
                             dryrun=options.dryrun, force=options.force)
    if options.report_unexpected_files:
      ReportUnexpectedFilesInDestDir(dest, expected_files,
                                     options.ignore_unexpected_children)
  except ArgumentError, arg_error:
    sys.exit("%s: %s" % (argv[0], arg_error.args[0]))
  except UnexpectedFileError, unexpected_file:
    sys.exit("%s: %s" % (argv[0], unexpected_file.args[0]))


if __name__ == "__main__":
  main(sys.argv)
