#!/bin/bash

# Run a command and send a mail if the command fails or produces output.  Use
# --ignore_exit_status to only send mail if output is produced.
# Redirects stdout and stderr, so if your command or caller does that it won't
# work properly.

set -e -f -u -o pipefail

main() {
  local IGNORE_EXIT_STATUS=0
  if [[ "${1:-}" == "--ignore_exit_status" ]]; then
    IGNORE_EXIT_STATUS=1
    shift
  fi
  local DESTINATION="$1"
  shift
  readonly IGNORE_EXIT_STATUS DESTINATION
  if [[ "$#" -eq 0 ]]; then
    printf "No command to run!\\n" >&2
    exit 1
  fi

  local EXIT_STATUS=0
  "$@" > "${OUTPUT_FILE}" 2>&1 || EXIT_STATUS="$?"

  local SEND_MAIL=0
  if [[ "${EXIT_STATUS}" -ne 0 && "${IGNORE_EXIT_STATUS}" -eq 0 ]]; then
    SEND_MAIL=1
  fi
  if [[ -s "${OUTPUT_FILE}" ]]; then
    SEND_MAIL=1
  fi

  # Support overriding the subject prefix to make testing idempotent.
  local SUBJECT="${SUBJECT_PREFIX:-${USER}@${HOSTNAME}}: $*"
  if [[ "${SEND_MAIL}" -eq 1 ]]; then
    (printf "Exit status: %s\\nOutput:\\n" "${EXIT_STATUS}";
      cat "${OUTPUT_FILE}"
    ) | mail -s "${SUBJECT}" "${DESTINATION}"
  fi
  return "${EXIT_STATUS}"
}

# Set this up unconditionally so it is set up once and cleaned up once,
# including during testing.
OUTPUT_FILE="$(mktemp -t send-mail-on-failure-or-output.XXXXXXXXXXXXXXXX)"
trap 'rm -f "${OUTPUT_FILE}"' EXIT

# Only run main if being executed directly; do nothing if sourced for testing.
# Use basename so that it can be run as 'bash -x ./program ...'.
if [[ "$(basename "${BASH_SOURCE[0]}")" == "$(basename "${0}")" ]]; then
  main "$@"
fi
