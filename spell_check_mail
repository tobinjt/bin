#!/usr/bin/env perl

# TODO TODO stress test
# TODO TODO cleanup the code.
# TODO TODO save filenames for tempfiles
# TODO TODO improve documentation.

# spell_check_mail is a program to seperate the mail you're composing
# into quoted and non-quoted chunks, then run a spell checker on the
# non-quoted chunks and finally put it all back together correctly, so
# that you don't spell check other people's awful spelling.
# $Id$

use strict;
use warnings;

use Getopt::Long	qw ();
use IO::File		qw ();
use File::Spec		qw ();
use File::Temp		qw ( tempfile tempdir );
use Pod::Usage		qw ();
use Fcntl		qw ( SEEK_SET );

use vars qw ( %Options $TempDir @All_files @Check_these $Quoted $Check_me);

sub spell_check ();
sub cleanup ();
sub quoted (@);
sub original (@);
sub my_die (@);
sub get_options ();
sub save_pattern ($$$);


get_options ();

my $success = 0;
# XXX  There's a continue block following this while loop, so all the tempfiles
# should be cleaned up properly even if we use C<next>.
ALL_FILES: foreach my $file ( @ARGV ) {
	# files to be reassembled after checking - includes files to be checked
	undef @All_files;
	# files to be checked
	undef @Check_these;
	# Filehandles.
	$Quoted = $Check_me = undef;

	my $file_fd = new IO::File ( "< $file" );
	unless ( $file_fd ) {
		warn "$0: failed to open $file\: $!\n";
		next ALL_FILES;
	}

	if ( $Options{backup} ) {
		my $bakname = "$file.bak";
		my $bak = new IO::File ( "> $bakname" )
			or die "$0: failed to open backup file $bakname\: $!\n";
		print $bak "", <$file_fd>
			or die "$0: failed to copy $file to $bakname\: $!\n";
		$file_fd->seek ( 0, SEEK_SET )
			or die "$0: failed to return to start of $file\: $!\n";
	}

	# Grab the headers
	while ( <$file_fd> ) {
		if ( $Options{"check-headers"} ) {
			# If we're checking the headers, they're equivalent to
			# unquoted text.
			original ($_ );
		} else {
			quoted ( $_ );
		}
		# Headers end at the first blank line, AFAIK.
		m/^$/ and last;
	}

	# Grab the rest of the mail.
	while ( <$file_fd> ) {
		if ( m/$Options{pattern}/o ) {
			# quoted text - don't check
			quoted ( $_ );
		} else {
			# new content - check it
			original ($_ );
		}
	}

	unless ( spell_check () ) {
		warn "$0: Spell check of $file failed\n";
		next ALL_FILES;
	}

	my ( $new_file_fd, $new_file )
			= tempfile ( "$file.scm-$$-$>-XXXXXXXXXXXXXXXX")
		or my_die "Failed to create replacement file: $!\n";

	foreach my $tmpfile ( @All_files ) {
		my $tmpfile_fd = new IO::File ( "< $tmpfile" )
			or my_die "$0: failed to open $tmpfile\: $!\n";
		unless ( print $new_file_fd "", <$tmpfile_fd> ) {
			warn "$0: failed to read $tmpfile\: $!\n";
			next ALL_FILES;
		}
	}

	if ( rename $new_file, $file ) {
		$success++;
	} else {
		warn "$0: Failed to replace original file ($file): $!\n";
	}
} continue {
	cleanup;
}

rmdir $TempDir
	or warn "$0: Failed to remove temporary directory $TempDir\: $!\n";

unless ( @ARGV == $success ) {
	my_die "$0: failed checking " . ( @ARGV - $success ) . "/"
		. scalar @ARGV . " files\n";
}
exit 0;

sub spell_check () {

	# system's return value is backwards.  perl6 will fix that :)
	if ( not $Options{"one-at-a-time"} ) {
		return not ( system $Options{spell}, @{$Options{arguments}},
			@Check_these );
	}

	# we need to loop round the arguments for programs like aspell which
	# only take one file at a time.
	foreach my $file ( @Check_these ) {
		system $Options{spell}, @{$Options{arguments}}, $file
			and return;
	}

	# all completed successfully.
	return 1;
}

sub cleanup () {
	foreach my $tempfile ( @All_files ) {
		unlink $tempfile
			or warn "$0: failed to delete tempfile "
				. "($tempfile): $!\n";
	}
}

sub my_die (@) {
	warn @_;
	cleanup;
	-d $TempDir and rmdir $TempDir
		or warn "$0: Failed to remove temp directory $TempDir\: $!\n";
	exit 1;
}

# quoted and original are repetitive, but I got fed up with the fiddlyness of
# doing it in one sub.
sub original (@) {
	if ( $Quoted ) {
		$Quoted->close () or
			my_die "$0: Failed to close tempfile: $!\n";
		undef $Quoted;
	}

	unless ( $Check_me ) {
		my $file;
		( $Check_me, $file ) = File::Temp::tempfile ( DIR => $TempDir )
			or my_die "$0: Failed to create tempfile: $!\n";
		push @All_files, $file;
		push @Check_these, $file;
	}

	print $Check_me @_
		or my_die "$0: failed writing tempfile: $!\n";
}

sub quoted (@) {
	if ( $Check_me ) {
		$Check_me->close () or
			my_die "$0: Failed to close tempfile: $!\n";
		undef $Check_me;
	}

	unless ( $Quoted ) {
		my $file;
		( $Quoted, $file ) = File::Temp::tempfile ( DIR => $TempDir )
			or my_die "$0: Failed to create tempfile: $!\n";
		push @All_files, $file;
	}

	print $Quoted @_
		or my_die "$0: failed writing tempfile: $!\n";
}

sub get_options () {
	%Options = (	help		=> 0,
			"check-headers"	=> 0,
			"one-at-a-time" => 0,
			tmpdir		=> File::Spec->tmpdir (),
			pattern		=> qr/^>/,
			spell		=> undef,
			argument	=> [],
			backup		=> 0,
		   );
	Getopt::Long::Configure qw ( no_getopt_compat gnu_getopt );
	Getopt::Long::GetOptions (
			\%Options,
			"help|h",
			"check-headers!",
			"c" => sub { $Options{"check-headers"} = 1; },
			"one-at-a-time!",
			"o" => sub { $Options{"one-at-a-time"} = 1; },
			"tmpdir|t=s",
			"pattern|p|regex|r=s" => \&save_pattern,
			"spell=s",
			"argument|arg|a=s",
			"backup!",
			"b" => sub { $Options{backup} = 1; },
		) or Pod::Usage::pod2usage ( 2 );
	$Options{help} and Pod::Usage::pod2usage ( -verbose => 2 );
	@ARGV or Pod::Usage::pod2usage ( 2 );

	# arguments make more sense, but the option name is argument.
	$Options{arguments} = $Options{argument};
	# Default arguments set here iff no arguments have been provided AND an
	# alternate spell checker hasn't been specified.
	unless ( defined $Options{spell} or @{$Options{arguments}} ) {
		 push @{$Options{arguments}}, "-x", "-B";
	}
	# default spell checker if none has been specified.
	unless ( defined $Options{spell} ) {
		$Options{spell} = "ispell";
	}


	$TempDir = tempdir ( File::Spec->catdir ( $Options{tmpdir},
			"scm-$$-$>-XXXXXXXXXXXXXXXX" ) )
		or die "$0: Failed to create temporary directory: $!\n";
}

sub save_pattern ($$$) {
	$Options{$_[1]} = qr/$_[2]/o
		or die "$0: failed to compile pattern -> $_[2]\n";
}

=pod

=head1 NAME

B<spell_check_mail> - spell check non-quoted text in an email.

=head1 SYNOPSIS

B<spell_check_mail> [OPTION]... file [file2 [file3 [...]]]

Options are:

 -h, --help               Display this help message.
 -c, --[no]check-headers  Check mail headers too.
 -o, --[no]one-at-a-time  Only pass one file to the spell
                          checker at a time.
 -t, --tmpdir <DIR>       Use <DIR> for temporary files.
 -r, --regex <REGEX>      Lines matching <REGEX> are quoted
                          lines, lines not matching it are
			  non-quoted (i.e. your) text.
 -p, --pattern <REGEX>    Equivalent to --regex
 -s, --spell <PROGRAM>    Use <PROGRAM> for spell checking,
                          removing default arguments.
 -a, --argument <ARG>     Add <ARG> to the list of spell
                          checker arguments, overriding
                          default arguments.
 -b, --[no]backup         Create backups before checking.

Some options can be negated as shown.

=head1 DESCRIPTION

B<spell_check_mail>

=head1 OPTIONS

=over 4

Some options can be negated as shown below.

=item --help|-h

Display this help message.

=item --[no]check-headers|-c

Spell check the headers of the mail too; by default B<spell_check_mail>
won't check them.

=item --[no]one-at-a-time|-o

B<spell_check_mail> splits your mail up into multiple small files and
then runs an external spell checking program on those files.  By default
B<spell_check_mail> will pass as many files as possible to the external
spell checker at once, but L<aspell> (and possibly other programs) only
accept one file per invocation.  This option instructs
B<spell_check_mail> to only pass one file per invocation, so that you
can use L<aspell>.

=item --tmpdir|-t <DIR>

Specifies the directory to put tempfiles in.
B<spell_check_mail> defaults to $TMPDIR, or /tmp if $TMPDIR isn't set.

=item --pattern|-p|--regex|-r <REGEX>

Set the Regular Expression used to distinguish quoted text from
non-quoted text.  Lines which match this regex are quoted, other lines
are non-quoted (i.e. the lines you've just written).  Defaults to /^>/,
viz any lines starting with > are quoted, all other lines are not.

XXX TODO XXX TODO what happens if someone puts the /s in the pattern?
Most likely everything breaks :(

=item --spell|-s program

Set the spell checking program to use.  Don't specify any arguments
here, use B<--argument> instead.  The default program is L<ispell>.

=item --argument|--arg|-a <ARG>

Specify B<an> argument to pass to the spell checking program.  The
default arguments ("-x", "-B") will B<not> be used.  This option can be
used multiple times and the arguments will accumulate.  Arguments will
be passed to the spell checking program B<in the order given and exactly
as given>.  Notice that this option takes B<one> argument - if you want
to pass multiple arguments, use B<--argument> multiple times.  The
arguments won't be interpreted by B<spell_check_mail>, nor will any
shell expansion will be performed on them.

Correct usage:

 spell_check_mail --argument -f --argument=-z my.mail

Incorrect usage:

 spell_check_mail --argument '-f -z' my.mail

The rationale for this is that this allows complicated arguments to be
passed unhindered to the spell checker; if my code interpreted the
arguments or they were passed to the shell then doing complicated things
would suddenly be much harder.

TODO TODO XXX XXX This section really should be improved.

=item --[no]backup|-b

Create a backup (<file>.bak) before doing anything to <file>. If
<file>.bak exists it will be overwritten.  B<spell_check_mail> defaults
to not making a backup.

=back

=head1 FILES

Only those files specified on the command line, and backups if requested.

=head1 EXAMPLES

TODO TODO XXX XXX Add examples.

=head1 BUGS

The code is extremely paranoid and tries to ensure that your mail won't
be damaged in any way, but it's probably not perfect.  That said, I've
been using it for a while without any problems.

=head1 AUTHOR

John Tobin <tobinjt@netsoc.tcd.ie>

This program was inspired by the awful spelling of many of the Netsoc
committee (http://www.netsoc.tcd.ie/) and their inability to use a spell
checker.  Skipping their misspellings when replying annoyed me, and I'm
Lazy enough that I wrote this to avoid that hassle.

=head1 COPYRIGHT

Copyright (C) 2003 John Tobin.  All Rights Reserved.

$Id$

This program is free software; you can redistribute it and/or modify it
under
the same terms as Perl itself.

=head1 SEE ALSO

L<IO::File>, L<Getopt::Long>, L<Pod::Usage>, L<File::Temp>,
L<File::Spec>, L<perl>

=cut
