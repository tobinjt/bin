#!/bin/bash

set -e -f -u -o pipefail

warn() {
  echo -e "$@" 1>&2
}
die() {
  warn "$@"
  exit 1
}

find_sources() {
  find "$1" -maxdepth 1 -mindepth 1 -iname "$2" -type d | sort
}

dotfiles_sources() {
  find_sources "${HOME}/src" '*dotfiles*'
}

bin_sources() {
  find_sources "${HOME}" '*bin*'
}

check_git_status() {
  local dir="${1}"
  cd "${dir}"
  if [[ ! -d ".git" ]]; then
    return
  fi
  local git_status
  git_status="$(git status --short)"
  if [[ -n "${git_status}" ]]; then
    die "Uncommitted changes in ${dir}:\n" "${git_status}"
  fi
}

update_git_checkout_and_push() {
  if [[ "$#" -ne 1 ]]; then
    die "update_git_checkout_and_push needs one argument, got $#"
  fi
  local dir="$1"
  echo "Processing ${dir}"
  cd "${dir}"
  if [[ ! -d ".git" ]]; then
    echo "Not a git repository: ${dir}"
    return
  fi

  # Refuse to do anything if there are uncommitted changes.
  check_git_status "${dir}"

  # Always pull and update submodules.  Note that if we fail before submodules
  # are completely updated there will be uncomitted changes that must be dealt
  # with manually.
  git pull
  git submodule init
  git submodule update

  # We can't push to https:// URLs.
  local repo_url
  repo_url="$(git config --get remote.origin.url)"
  if [[ "${repo_url:0:8}" != "https://" ]]; then
    git push
  else
    echo "Cannot push to https:// URLs."
  fi
}

main() {
  if [[ "$#" -ne 0 ]]; then
    warn "Unexpected arguments: $@"
    die "Usage: $0"
  fi
  echo "Running dotfiles to check for pre-existing diffs."
  # First make sure we're up to date so that current diffs aren't mixed in with
  # future diffs.
  dotfiles

  # Update bin dirs.
  local orig_code
  orig_code="$(cat "${BASH_SOURCE[0]}")"
  local dir
  for dir in $(bin_sources); do
    update_git_checkout_and_push "${dir}"
    # Check for unfinished changes; this happens when submodules are removed
    # because git won't delete the submodule directory.
    check_git_status "${dir}"
  done
  local new_code
  new_code="$(cat "${BASH_SOURCE[0]}")"
  if [[ "${orig_code}" != "${new_code}" ]]; then
    echo "Restarting with updated tools"
    exec "${BASH_SOURCE[0]}"
  fi

  # Check for diffs again with possibly new binaries.
  dotfiles

  # Update all dotfiles.
  for dir in $(dotfiles_sources); do
    update_git_checkout_and_push "${dir}"
    # Forcibly update.  There is a risk that we clobber a file in our home
    # directory with a file we've just checked out, but the alternative is for
    # the user to forcibly update manually.
    dotfiles -f
    # Check for unfinished changes; this happens when submodules are removed
    # because git won't delete the submodule directory.  Do this after running
    # dotfiles, otherwise there is a high chance that the next run of this
    # program will find diffs and will exit.
    check_git_status "${dir}"
  done

  # Report unexpected files.
  dotfiles -r
}

# Make sure $HOME/bin is in $PATH to support running
#   "ssh foo@bar update-dotfiles-and-bin"
PATH="${PATH}:${HOME}/bin"
export PATH
main "$@"
