#!/usr/bin/env perl

eval 'exec /usr/bin/perl  -S $0 ${1+"$@"}'
    if 0; # not running under some shell

$SID{__DIE__} = sub {
    # Ensure that the exit status is 2.
    $! = 2;
};

use strict;
use warnings;

use IkiWiki 3.00;
use IkiWiki::Setup;
use File::Spec::Functions qw(catfile);
use File::Slurp qw(read_file write_file read_dir);
use Getopt::Long;
use Pod::Usage;

my $VERSION = '0.05';

use Data::Dumper;
$Data::Dumper::Sortkeys = 1;

my %options = get_options();

my ($config_file, $output_directory) = @ARGV;
IkiWiki::Setup::load($config_file);
IkiWiki::checkconfig();
IkiWiki::loadindex();
check_output_directory($output_directory);
my $template = read_template();

my %_uniq_tags;
my @tags =
    grep {  $_ ne qq{$config{tagbase}/discussion}
            and not m!/discussion$ !x
            and s!^(?:/)?$config{tagbase}/!!o
            and not $_uniq_tags{$_}++
        }
        map { @{$_} }
            values %links;

my $changes_made = 0;
TAG:
foreach my $tag (@tags) {
    my $file = catfile($output_directory, qq{$tag.mdwn});
    if (-e $file) {
        next TAG;
    }

    if ($options{verbose}) {
        print qq{$0: creating $file\n};
    }
    if ($options{report}) {
        next TAG;
    }

    my $content = $template;
    $content =~ s/__TAG__/$tag/g;
    write_file($file, {atomic => 1}, $content);
    $changes_made++;
}

my %tags = map { ($_ => 1) } @tags;
FILE:
foreach my $file (read_dir($output_directory)) {
    my $tag = $file;
    if ($tag !~ s/\.mdwn$//) {
        next FILE;
    }
    if (exists $tags{$tag}) {
        next FILE;
    }

    my $expected_content = $template;
    $expected_content =~ s/__TAG__/$tag/g;
    my $full_path = catfile($output_directory, $file);
    my $actual_content = read_file($full_path);
    if (($options{delete} or $options{report})
            and $expected_content ne $actual_content) {
        if ($options{verbose}) {
            print <<"TEMPLATE";
$0: $full_path is unnecessary, but it contains custom content, so it will not be removed
TEMPLATE
        }
        next FILE;
    }

    if ($options{verbose}) {
        print qq{$0: removing $full_path\n};
    }
    if ($options{report}) {
        next FILE;
    }
    if (not $options{delete}) {
        next FILE;
    }

    1 while (unlink $full_path);
    if (-e $full_path) {
        die qq{$0: failed deleting $full_path: $!\n};
    }
    $changes_made++;
}

if ($options{report}) {
    exit 0;
}
if ($changes_made) {
    exit 0;
}
exit 1;


sub get_options {
    my %options_accepted = (
        q{help|h}       => 0,
        q{version|V}    => 0,
        q{verbose|v}    => 0,
        q{delete|d}     => 0,
        q{report|r}     => 0,
    );
    my %options;
    while (my ($key, $value) = each %options_accepted) {
        $key =~ s/[|=].*//;
        $options{$key} = $value;
    }

	Getopt::Long::Configure(qw(no_getopt_compat gnu_getopt));
	Getopt::Long::GetOptions(\%options, keys %options_accepted)
        or pod2usage(2);
    if ($options{help}) {
        pod2usage(1);
    }
    if ($options{version}) {
        print qq{ikiwiki-generate-tags-pages version $VERSION\n};
        exit 1;
    }
    if ($options{report}) {
        $options{verbose} = 1;
    }
    if (@ARGV != 2) {
        pod2usage(2);
    }

    return %options;
}

sub check_output_directory {
    my ($output_directory) = @_;

    if ($output_directory !~ m/\/$config{tagbase}(?:\/)?$/) {
        die <<"BAD_DIRECTORY";
$0: output directory '$output_directory' does not end with tagbase '$config{tagbase}'
BAD_DIRECTORY
    }

    if (not -d $output_directory) {
        die <<"MISSING_DIRECTORY";
$0: output directory '$output_directory' does not exist
MISSING_DIRECTORY
    }
}

sub read_template {
    my $template_name = q{tag_template.mdwn};
    my ($template_filename) = IkiWiki::srcfile_stat($template_name, 1);
    if (not $template_filename) {
        return <<'TEMPLATE';
[[!inline pages="tagged(__TAG__)" archive="yes"]]
TEMPLATE
    }

    my $template = read_file($template_filename);
    if ($template !~ m/__TAG__/) {
        die <<"BAD_TEMPLATE"
$0: template in $template_filename does not contain __TAG__
BAD_TEMPLATE
    }

    return $template;
}

=pod

=head1 NAME

ikiwiki-generate-tags-pages - generate a page for every tag you use

=head1 SYNOPSIS

B<ikiwiki-generate-tags-pages> [OPTIONS] CONFIG_FILE OUTPUT_DIRECTORY

CONFIG_FILE is the same config file you use with 'ikiwiki --setup CONFIG_FILE'

OUTPUT_DIRECTORY is the directory you would write the pages in yourself,
typically '.../tags' (unless you've changed the tagbase option in your
CONFIG_FILE).

=head1 DESCRIPTION

IkiWiki's tag plugin lets you tag pages, but to see all the pages tagged with
'foo', you need to manually create a page containing:

    [[!inline pages="tagged(foo)" archive="yes"]]

B<ikiwiki-generate-tags-pages> creates those pages for you.  It uses data
gathered by B<IkiWiki>, so you need to run it B<after> running B<IkiWiki>.

=head2 Template

The built-in template is:

    [[!inline pages="tagged(__TAG__)" archive="yes"]]

This can be overridden by creating a file named F<tag_template.mdwn> in your
wiki, just like F<sidebar.mdwn> or F<shortcuts.mdwn>.  The template must contain
B<__TAG__> at least once.

The string B<__TAG__> will be replaced with the current tag when the template is
written to each output file.

=head2 Typical usage.

You'll usually run B<ikiwiki-generate-tags-pages> after adding a new page to
your wiki.  The sequence of steps will resemble the following:

    write page
    commit page to VCS
    refresh wiki
    ikiwiki-generate-tags-pages
    commit any generated pages to VCS
    refresh wiki

=head2 post-commit hook

You can automate the process of creating missing tag pages with a post-update
hook, e.g.:

    #!/bin/sh

    set -e

    # Run ikiwiki's post-update hook
    /master/repository/.git/hooks/post-update.ikiwiki
    cd /my/repository
    if ikiwiki-generate-tags-pages --setup ~/.ikiwiki/my-setup tags; then
        git add tags/*
        git commit --message "Committed tag files"
        git push
    fi

This has a few problems: it will commit anything you already have in your
staging area; you need to change where ikiwiki writes its own post-update hook.

=head1 OPTIONS

=over 4

=item B<-h,> B<--help>

Print a help message, and exit.

=item B<-V,> B<--version>

Print a help message, and exit.

=item B<-v,> B<--verbose>

Enable verbose execution.

=item B<-d>, B<--delete>

Delete unnecessary tag pages, i.e. pages for tags that are no longer used.  A
page will only be deleted if it exactly matches the rendered template, so this
option will not delete custom pages.

=item B<-r>, B<--report>, B<--debug>

Don't make any changes, simply report the changes that should be made.

=back

=head1 EXIT STATUS

=over 4

=item B<0:>

The filesystem was modified in some way, or the B<--report> option was given.

=item B<1:>

The filesystem was not modified in any way, and the B<--report> option was not
given.

=item B<2:>

There was either an internal error, or an attempt to change the filesystem
failed.  The error message should provide some useful information.

=back

The exit statuses were chosen to allow you to easily write post-update hooks
like the example above.

=head1 DEPENDENCIES

=over 4

=item File::Slurp

=item IkiWiki

B<ikiwiki-generate-tags-pages> has been written for IkiWiki 3.0, but may work
with earlier versions; if you successfully use it with earlier versions, please
inform the author.

=back

=head1 AUTHOR

John Tobin <john DOT tobin AT johntobin DOT ie>

=head1 BUGS

Please report any bugs or feature requests to the author; patches or tests will
be gratefully accepted.

=head1 VERSION

0.05

=head1 COPYRIGHT & LICENSE

Copyright (C) 2009 John Tobin.  All Rights Reserved.

This module is free software; you can redistribute it and/or modify it under the
same terms as Perl itself.

=head1 SEE ALSO

L<ikiwiki> 

=cut
