#!/bin/bash

set -e -f -u -o pipefail

usage() {
  printf "%s: DIRECTORY [DIRECTORY...]\\n" "$0"
}

git_pull_and_push_if_possible() {
  # Explicitly enable the old default behaviour so that git doesn't spew
  # warnings.
  git config pull.rebase false
  if ! git config remote.origin.url >& /dev/null; then
    # Pull and push requires an origin.
    return
  fi
  if git transport-is-ssh && [[ -z "${SSH_AUTH_SOCK:-}" ]]; then
    # SSH transport requires ssh-agent.
    return
  fi
  git pull --quiet
  # Can't push to HTTPS repos without auth.
  if ! git transport-is-https; then
    git push
  fi
}

check_pre-commit_is_installed() {
  local config_file=".pre-commit-config.yaml"
  if [[ ! -f "${config_file}" ]]; then
    return 0
  fi
  if ! git transport-is-ssh; then
    # We don't need pre-commit if we're not committing.
    return 0
  fi
  local hook_file=".git/hooks/pre-commit"
  local legacy_hook_file="${hook_file}.legacy"
  if [[ -L "${legacy_hook_file}" || -e "${legacy_hook_file}" ]]; then
    printf "%s/%s exists\n" "${PWD}" "${legacy_hook_file}" >&2
  fi
  if [[ "${config_file}" -nt "${hook_file}" ]]; then
    printf "Installing pre-commit in %s\n" "${PWD}"
    pre-commit install --install-hooks
  fi
  # Unconditionally install hooks; this is a quiet no-op if hooks are already
  # installed.
  pre-commit install-hooks
  if ! grep -q -F 'File generated by pre-commit' "${hook_file}"; then
    printf "%s/%s exists but is not configured by pre-commit\n" \
      "${PWD}" "${hook_file}" >&2
    return 1
  fi
  return 0
}

# Check that git repos don't have any uncommitted, unpushed, or unpulled
# changes.
check_single_repo() {
  if [[ ! -d ".git" ]]; then
    # Make it easy to run "check-git-repos ~/src/*".
    return 0
  fi
  # Pull to start with so that unpulled changes don't cause failures.
  git_pull_and_push_if_possible
  git check-local-copy-is-clean
  check_pre-commit_is_installed
}

main() {
  while [[ "$#" -gt 0 ]]; do
    case "${1}" in
      -*)
        usage >&2
        return 1
        ;;
      *)
        break
        ;;
    esac
  done

  local repo result=0
  for repo in "$@"; do
    # Make it easy to run "check-git-repos ~/src/*".
    if [[ ! -d "${repo}" ]]; then
      continue
    fi
    if [[ -t 0 ]]; then
      printf "%s\\n" "${repo}"
    fi
    # Bizzare Posix sh behaviour :(  See
    # https://unix.stackexchange.com/questions/65532/why-does-set-e-not-work-inside-subshells-with-parenthesis-followed-by-an-or
    (cd "${repo}"; check_single_repo) &
    if ! wait "$!"; then
      result=1
    fi
  done
  return "${result}"
}

# Stop git looking for a commit message when 'git pull' is run.
GIT_MERGE_AUTOEDIT=no
export GIT_MERGE_AUTOEDIT
main "$@"
