#!/bin/bash

set -e -f -u -o pipefail

PATH="${HOME}/bin:${PATH}"

# Check that git repos don't have any uncommitted, unpushed, or unpulled
# changes.
check_single_repo() {
  local pull="$1"
  if [[ ! -d ".git" ]]; then
    # Make it easy to run "check-git-repos ~/src/*".
    return 0
  fi
  if git check-local-copy-is-clean; then
    return 0
  fi
  if [[ "${pull}" -eq 0 ]]; then
    return 1
  fi
  if git config remote.origin.url >& /dev/null; then
    # Pull and push requires an origin.
    git pull
    # Can't push to HTTPS repos without auth.
    if ! git transport-is-https; then
      git push
    fi
  fi
  git check-local-copy-is-clean
}

main() {
  local pull=0
  if [[ "$#" -gt 0 && "$1" == "--pull" ]]; then
    pull=1
    shift
  fi
  local repo result=0
  for repo in "$@"; do
    # Make it easy to run "check-git-repos ~/src/*".
    if [[ ! -d "${repo}" ]]; then
      continue
    fi
    # Bizzare Posix sh behaviour :(  See
    # https://unix.stackexchange.com/questions/65532/why-does-set-e-not-work-inside-subshells-with-parenthesis-followed-by-an-or
    (cd "${repo}"; check_single_repo "${pull}") &
    if ! wait "$!"; then
      result=1
    fi
  done
  return "${result}"
}

main "$@"
