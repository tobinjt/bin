#!/bin/bash

set -e -f -u -o pipefail

# ${HOME}/bin is needed for `git transport-is-ssh`.
# /usr/local/bin is needed for `pre-commit`.
PATH="${HOME}/bin:/usr/local/bin:${PATH}"

usage() {
  printf "%s: [--pull_and_push] DIRECTORY [DIRECTORY...]\\n" "$0"
}

git_pull_and_push_if_possible() {
  # Explicitly enable the old default behaviour so that git doesn't spew
  # warnings.
  git config pull.rebase false
  if git config remote.origin.url >& /dev/null; then
    # Pull and push requires an origin.
    git pull
    # Can't push to HTTPS repos without auth.
    if ! git transport-is-https; then
      git push
    fi
  fi
}

check_pre-commit_is_installed() {
  local config_file=".pre-commit-config.yaml"
  if [[ ! -f "${config_file}" ]]; then
    return 0
  fi
  if ! git transport-is-ssh; then
    # We don't need pre-commit if we're not committing.
    return 0
  fi
  local hook_file=".git/hooks/pre-commit"
  if [[ "${config_file}" -nt "${hook_file}" ]]; then
    pre-commit install
  fi
  if ! grep -q -F 'File generated by pre-commit' "${hook_file}"; then
    printf "%s exists but is not configured by pre-commit\n" "${hook_file}" >&2
    return 1
  fi
  return 0
}

# Check that git repos don't have any uncommitted, unpushed, or unpulled
# changes.
check_single_repo() {
  local pull_and_push="$1"
  if [[ ! -d ".git" ]]; then
    # Make it easy to run "check-git-repos ~/src/*".
    return 0
  fi
  if [[ "${pull_and_push}" -eq 1 ]]; then
    # Pull to start with so that unpulled changes don't cause failures.
    git_pull_and_push_if_possible
  fi
  git check-local-copy-is-clean
  check_pre-commit_is_installed
}

main() {
  local pull_and_push=0
  while [[ "$#" -gt 0 ]]; do
    case "${1}" in
      --pull_and_push)
        pull_and_push=1
        shift
        ;;
      -*)
        usage >&2
        return 1
        ;;
      *)
        break
        ;;
    esac
  done
  readonly pull_and_push

  local repo result=0
  for repo in "$@"; do
    # Make it easy to run "check-git-repos ~/src/*".
    if [[ ! -d "${repo}" ]]; then
      continue
    fi
    if [[ -t 0 ]]; then
      printf "%s\\n" "${repo}"
    fi
    # Bizzare Posix sh behaviour :(  See
    # https://unix.stackexchange.com/questions/65532/why-does-set-e-not-work-inside-subshells-with-parenthesis-followed-by-an-or
    (cd "${repo}"; check_single_repo "${pull_and_push}") &
    if ! wait "$!"; then
      result=1
    fi
  done
  return "${result}"
}

# Stop git looking for a commit message when 'git pull' is run.
GIT_MERGE_AUTOEDIT=no
export GIT_MERGE_AUTOEDIT
main "$@"
