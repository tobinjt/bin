#!/bin/bash

set -e -f -u -o pipefail

main() {
  local ignore_unpushed_commits=0
  if [[ "$#" -eq 1 && "$1" == "--ignore-unpushed-commits" ]]; then
    ignore_unpushed_commits=1
    shift
  fi
  if [[ "$#" -ne 0 ]]; then
    printf "Usage: %s [--ignore-unpushed-commits]\\n" "$0" >&2
    return 1
  fi

  local rootdir
  rootdir="$(git rev-parse --show-toplevel)"
  # Check for uncommitted changes.
  local output result=0
  output="$(git status --short)"
  if [[ -n "${output}" ]]; then
    # Use human readable git status because it's more familiar.
    printf "Uncommitted changes in %s\\n" "${rootdir}" >&2
    git status >&2
    result=1
  fi

  if [[ "${ignore_unpushed_commits}" -eq 1 ]]; then
    return "${result}"
  fi

  # Check for unpushed commits.
  if ! git symbolic-ref HEAD >& /dev/null; then
    # Dunno exactly what's happening here, but checking for unpushed commits
    # doesn't work so skip it.
    return "${result}"
  fi
  if ! git config remote.origin.url >& /dev/null; then
    # No upstream, so don't check that.
    return "${result}"
  fi
  if ! git log "@{upstream}.." >& /dev/null; then
    local branch
    branch="$(git branch | awk '$1 == "*" { print $2 }')"
    git branch --set-upstream-to="origin/${branch}" "${branch}"
  fi
  output="$(git log "@{upstream}..")"
  if [[ -n "${output}" ]]; then
    printf "Unpushed commits in %s\\n%s\\n" "${rootdir}" "${output}" >&2
    result=1
  fi
  return "${result}"
}

main "$@"
